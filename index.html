<!DOCTYPE html>
<meta charset="utf-8">

<style>
    path {
        fill: #ddd;
        fill-opacity: .8;
        stroke: #fff;
        stroke-width: 1.5px;
    }

    line {
        stroke: #999;
    }
</style>

<svg width="960" height="600"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script>

    var fixedRegions = ["KGD", "KAM", "CHU", "DA", "SMO", "PSK", "SAK", "ZAB"];
    function isFixedRegion(region) {
        var iso = region.properties.ISO_2;
        return fixedRegions.indexOf(iso) > -1;
    }

    function isCity(region) {
        return region.properties.NAME_1.includes("City");
    }

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var projection = d3.geoConicEquidistant()
        .rotate([-105, 0])
        .center([-10, 65])
        .scale(width * 0.7)
        .translate([width / 2, height / 2]);

    var path = d3.geoPath().projection(projection);

    var voronoi = d3.voronoi()
        .size([width, height])
        .x((d) => d.x)
        .y((d) => d.y);


    d3.json("data/russia.topo.json", function (error, russia) {
        if (error) throw error;

        var geo = topojson.feature(russia, russia.objects.regions).features;

        var regions = [];

        geo.forEach(function (item, i) {
            if (isCity(item)) { return; }
            var centroid = path.centroid(item);
            var region = {
                x: centroid[0],
                y: centroid[1]
            };
            if (isFixedRegion(item)) {
                region.fx = region.x;
                region.fy = region.y;
            }
            region.radius = Math.sqrt(path.area(item) / Math.PI);
            regions.push(region);
        });

        regions.sort(function (a, b) { return b.radius - a.radius; });
        var links = voronoi.links(regions);
        var simulation = d3.forceSimulation(regions)
            .force("collide", d3.forceCollide().radius(function (d) { return d.radius; }))
            .on("tick", ticked);

        svg
            .append("g")
            .selectAll("path")
            .data(geo)
            .enter()
                .append("path")
                .attr("d", this.path)
                .style("fill", "rgba(0,0,0,0.1)");

        var hexbin = d3.hexbin()
            .extent([[0, 0], [width, height]])
            .x((d) => d.x)
            .y((d) => d.y)
            .radius(10);

        var regionVis = svg.append("g")
                    .attr("class", "hexagon")
                    .selectAll("path")
                        .data(regions).enter()
                        .append("path")
                            .attr("d", function(d) { return hexbin.hexagon(d.radius); })
                            .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
                            .style("fill", "rgba(0,150,250,0.7)");

        var linkVis = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(links).enter()
                        .append("line")
                            .attr("x1", function(d) { return d.source.x; })
                            .attr("y1", function (d) { return d.source.y; })
                            .attr("x2", function (d) { return d.target.x; })
                            .attr("y2", function (d) { return d.target.y; })
                            .style("stroke", "rgba(250, 0, 0, 0.1)");

        var ticked = function() {
            linkVis
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });
    
            regionVis
                .attr("transform", function(d) {
                    d.x = Math.max(d.radius, Math.min(width - d.radius, d.x));
                    d.y = Math.max(d.radius, Math.min(height - d.radius, d.y));
                    return "translate(" + d.x + "," + d.y + ")";
                });
        }  
        
        simulation
            .nodes(regions)
            .on("tick", ticked);
    
        simulation.force("link")
            .links(links);   

    });

</script>
